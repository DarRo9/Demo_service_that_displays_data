/* This is a service for getting contacts from a CRM service, saving them to/removing them from a database. 
The connection to the service is made using acces token and login. 
There is also a client that can send a delete request and receive a success/failure response from the server. */

package main

import (
	"context"
	"database/sql"
	"encoding/json"
	"fmt"
	proto "github.com/DarRo9/proto5"
	_ "github.com/lib/pq"
	"google.golang.org/grpc"
	"gorm.io/driver/postgres"
	"gorm.io/gorm"
	"io/ioutil"
	"log"
	"net"
	"net/http"
)

// AutoGenerated - структура для парсинга ответа в формате json.
type AutoGenerated struct {
	OrderUID    string `json:"order_uid"`
	TrackNumber string `json:"track_number"`
	Entry       string `json:"entry"`
	Delivery    struct {
		Name    string `json:"name"`
		Phone   string `json:"phone"`
		Zip     string `json:"zip"`
		City    string `json:"city"`
		Address string `json:"address"`
		Region  string `json:"region"`
		Email   string `json:"email"`
	} `json:"delivery"`
	Payment struct {
		Transaction  string `json:"transaction"`
		RequestID    string `json:"request_id"`
		Currency     string `json:"currency"`
		Provider     string `json:"provider"`
		Amount       int    `json:"amount"`
		PaymentDt    int    `json:"payment_dt"`
		Bank         string `json:"bank"`
		DeliveryCost int    `json:"delivery_cost"`
		GoodsTotal   int    `json:"goods_total"`
		CustomFee    int    `json:"custom_fee"`
	} `json:"payment"`
	Items []struct {
		ChrtID      int    `json:"chrt_id"`
		TrackNumber string `json:"track_number"`
		Price       int    `json:"price"`
		Rid         string `json:"rid"`
		Name        string `json:"name"`
		Sale        int    `json:"sale"`
		Size        string `json:"size"`
		TotalPrice  int    `json:"total_price"`
		NmID        int    `json:"nm_id"`
		Brand       string `json:"brand"`
		Status      int    `json:"status"`
	} `json:"items"`
	Locale            string    `json:"locale"`
	InternalSignature string    `json:"internal_signature"`
	CustomerID        string    `json:"customer_id"`
	DeliveryService   string    `json:"delivery_service"`
	Shardkey          string    `json:"shardkey"`
	SmID              int       `json:"sm_id"`
	DateCreated       time.Time `json:"date_created"`
	OofShard          string    `json:"oof_shard"`
}

// Access - структура для получения и хранения информации о токене
type Access struct {
	token string
}

/*
type AccesI interface {
	ContactsInf(string)
}
*/

// Contacts - структура для создания таблицы "contacts"
type Order struct {
	gorm.Model
	OrderUID    string `json:"order_uid"`
	TrackNumber string `json:"track_number"`
	Entry       string `json:"entry"`
	Locale            string    `json:"locale"`
	InternalSignature string    `json:"internal_signature"`
	CustomerID        string    `json:"customer_id"`
	DeliveryService   string    `json:"delivery_service"`
	Shardkey          string    `json:"shardkey"`
	SmID              int       `json:"sm_id"`
	DateCreated       time.Time `json:"date_created"`
	OofShard          string    `json:"oof_shard"`
	DeliveryID    int
	PaymentID	int
	ItemID	int
	
	
}

// Accounts - структура для создания таблицы "accounts"
type Delivery struct {
	gorm.Model
	Name    string `json:"name"`
	Phone   string `json:"phone"`
	Zip     string `json:"zip"`
	City    string `json:"city"`
	Address string `json:"address"`
	Region  string `json:"region"`
	Email   string `json:"email"`
	
}

type Payment struct {
		gorm.Model
		Transaction  string `json:"transaction"`
		RequestID    string `json:"request_id"`
		Currency     string `json:"currency"`
		Provider     string `json:"provider"`
		Amount       int    `json:"amount"`
		PaymentDt    int    `json:"payment_dt"`
		Bank         string `json:"bank"`
		DeliveryCost int    `json:"delivery_cost"`
		GoodsTotal   int    `json:"goods_total"`
		CustomFee    int    `json:"custom_fee"`
} 
	
type Item struct {
		gorm.Model
		ChrtID      int    `json:"chrt_id"`
		TrackNumber string `json:"track_number"`
		Price       int    `json:"price"`
		Rid         string `json:"rid"`
		Name        string `json:"name"`
		Sale        int    `json:"sale"`
		Size        string `json:"size"`
		TotalPrice  int    `json:"total_price"`
		NmID        int    `json:"nm_id"`
		Brand       string `json:"brand"`
		Status      int    `json:"status"`
} 

// AccountsInf - функция для добавления информации об аккаунте
func (at *Access) AccountsInf(atkn string, answerStruct AutoGenerated) {
	var id = 0
	for _, e := range answerStruct.Embedded.Contacts {
		id = e.AccountID
	}
	key := ""
	db.Create(&Accounts{IDAccount: id, AToken: atkn, KeyUni: key})
}

// ContactsInf - функция для добавления информации о контактах
func (at *Access) ContactsInf(answerStruct AutoGenerated) {
	var id_a = 0
	// printing details of
	// decoded data
	for _, e := range answerStruct.Embedded.Contacts {
		id_a = e.AccountID
		n := e.Name
		id := e.ID
		m := ""
		for _, e2 := range e.CustomFieldsValues {
			if e2.FieldCode == "EMAIL" {
				m = e2.Values[0].Value

			}
		}

		if m != "" {
			db.Create(&Contacts{IDContact: id, Name: n, Mail: m, IDAccount: id_a})
		}

	}

}

// Открываем бд
var db, _ = gorm.Open(mysql.Open("steven:here@tcp(127.0.0.1:3306)/fullstack_api"), &gorm.Config{})
var db2, _ = sql.Open("mysql", "steven:here@tcp(127.0.0.1:3306)/fullstack_api")

// Create_Tabs - функция для создания и заполнения таблиц
func Create_Tabs(atoken string) {
	url := "link with login and api"
	at := Access{atoken}
	var bearer = "Bearer " + at.token

	// Create a new request using http
	req, err := http.NewRequest("GET", url, nil)

	// add authorization header to the req
	req.Header.Add("Authorization", bearer)

	// Send req using http Client
	client := &http.Client{}
	resp, err := client.Do(req)
	if err != nil {
		log.Println("Error on response.\n[ERROR] -", err)
	}
	defer resp.Body.Close()

	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		log.Println("Error while reading the response bytes:", err)
	}

	var answerStruct AutoGenerated

	err2 := json.Unmarshal([]byte(body), &answerStruct)

	if err2 != nil {

		// if error is not nil
		// print error
		fmt.Println(err)
	}

	db.AutoMigrate(&Accounts{})
	db.AutoMigrate(&Contacts{})

	at.AccountsInf(atoken, answerStruct)
	at.ContactsInf(answerStruct)
}

// InfAboutA - функция для получения информации про аккаунты
func InfAboutA() {
	result2, err2 := db2.Query("Select id_account, a_token, key_uni from accounts")
	if err2 != nil {
		panic(err2)
	}

	defer result2.Close()
	type example2 struct {
		IDAccount int
		AToken    string
		KeyUni    string
	}
	products2 := []example2{}

	for result2.Next() {
		c2 := example2{}
		//err := result.Scan(&c.ID, &c.CreatedAt, &c.UpdatedAt, &c.DeletedAt, &c.IDAmoCRM, &c.Name, &c.Mail)
		err3 := result2.Scan(&c2.IDAccount, &c2.AToken, &c2.KeyUni)

		if err3 != nil {
			fmt.Println(err3)
			continue
		}
		products2 = append(products2, c2)
	}
	for _, c2 := range products2 {
		fmt.Println(c2.IDAccount, " ", c2.AToken, " ", c2.KeyUni)
	}
}
func InfAboutC() {
	result, err := db2.Query("Select id_contact, name, mail, id_account from contacts")
	if err != nil {
		panic(err)
	}

	defer result.Close()
	type example struct {
		IDContact int
		Name      string
		Mail      string
		IDAccount string
	}
	products := []example{}

	for result.Next() {
		c := example{}
		//err := result.Scan(&c.ID, &c.CreatedAt, &c.UpdatedAt, &c.DeletedAt, &c.IDAmoCRM, &c.Name, &c.Mail)
		err := result.Scan(&c.IDContact, &c.Name, &c.Mail, &c.IDAccount)

		if err != nil {
			fmt.Println(err)
			continue
		}
		products = append(products, c)
	}
	for _, c2 := range products {
		fmt.Println(c2.IDContact, " ", c2.Name, " ", c2.Mail, " ", c2.IDAccount)
	}
}

type Server struct {
}

func (s *Server) Do(ctx context.Context, in *proto.Request) (*proto.Response, error) {
	log.Printf("Receive message body from client: %s", in.Message)
	if in.Message == "Удоли" {
		fmt.Print("удалил")
		db.Exec("DELETE FROM contacts;")
		db.Exec("DELETE FROM accounts;")
		db.AutoMigrate(&Accounts{})
		db.AutoMigrate(&Contacts{})
		InfAboutA()
		InfAboutC()
		return &proto.Response{Message: "удалил"}, nil
	}
	return &proto.Response{Message: "не удалил"}, nil

}

func ServerF() {
	fmt.Println("Сервер запущен")

	lis, err := net.Listen("tcp", fmt.Sprintf(":%d", 9000))
	if err != nil {
		log.Fatalf("failed to listen: %v", err)
	}

	var s = Server{}

	grpcServer := grpc.NewServer()

	proto.RegisterDelAccServer(grpcServer, &s)

	if err := grpcServer.Serve(lis); err != nil {
		log.Fatalf("failed to serve: %s", err)
	}

}

func main() {

	defer db2.Close()
	//db2.Query("DROP TABLE contacts;")
	//db2.Query("DROP TABLE accounts;")
	Create_Tabs("eyJ0eXAiOiJKV1QiLCJhbGciOiJSUzI1NiIsImp0aSI6IjE1MDM3ZThhYTY3YjZhZTc4NjRmMTA2ODBhMzM3Nzk5YmIzMjNlM2Y4NDgzMjE0OGM5Njk1ODExNDVjY2EzODY1MjA5OTU5OGY1ZWJiMjVkIn0.eyJhdWQiOiI3NjlmNDk5OS04Y2VkLTQ1ZDEtYThkMy1kYTBkYTk4OGU3NzEiLCJqdGkiOiIxNTAzN2U4YWE2N2I2YWU3ODY0ZjEwNjgwYTMzNzc5OWJiMzIzZTNmODQ4MzIxNDhjOTY5NTgxMTQ1Y2NhMzg2NTIwOTk1OThmNWViYjI1ZCIsImlhdCI6MTY5MjI4MDMwNSwibmJmIjoxNjkyMjgwMzA1LCJleHAiOjE2OTIzNjY3MDUsInN1YiI6Ijk5MDc4NDIiLCJncmFudF90eXBlIjoiIiwiYWNjb3VudF9pZCI6MzEyMDk1MTQsImJhc2VfZG9tYWluIjoiYW1vY3JtLnJ1IiwidmVyc2lvbiI6InYyIiwic2NvcGVzIjpbInB1c2hfbm90aWZpY2F0aW9ucyIsImZpbGVzIiwiY3JtIiwiZmlsZXNfZGVsZXRlIiwibm90aWZpY2F0aW9ucyJdfQ.ZMAR5Erop_f-m5004pD4DXlQmAWVrwx0DgXN8oPnnRpXX0c32Y9NH2FS9lpSUAtCShwATmaLtUf-5CUqBLauA-P7i_XgevONjFqHMsZxW3NOs5Ci0UsmRU9vHbg0bIVxf0aWGn9bJBgRu68T3J3CPnPMKnHgrijYagfh9iq0rBvDQd2zk1WgwWiRJZonC_yBqsuN4_EsukXcGNsQCXTxg8De_SAk5LYOLmCRx8H8ODe11q3oiqDfc9kaHDm2q6gvVchHFvyaBjVFsEJ5R18BtG6bsPp0_q8rHCR7KDM_Vdzc3z3djzA3oH3X4ejS6rwbAmWnPw7Mjja0M4QTZDW_vg")

	InfAboutC()
	InfAboutA()
	ServerF()

}
